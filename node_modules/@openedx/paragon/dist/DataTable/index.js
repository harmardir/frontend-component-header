function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["columns", "data", "defaultColumnValues", "additionalColumns", "isSelectable", "isPaginated", "manualPagination", "pageCount", "itemCount", "isFilterable", "manualFilters", "fetchData", "initialState", "isSortable", "manualSortBy", "isExpandable", "renderRowSubComponent", "bulkActions", "tableActions", "numBreakoutFilters", "initialTableOptions", "EmptyTableComponent", "manualSelectColumn", "showFiltersInSidebar", "dataViewToggleOptions", "disableElevation", "isLoading", "children", "onSelectedRowsChanged", "maxSelectedRows", "onMaxSelectedRows"];
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import React, { useEffect, useMemo, useReducer } from 'react';
import PropTypes from 'prop-types';
import { useTable, useMountedLayoutEffect } from 'react-table';
import classNames from 'classnames';
import Table from './Table';
import getVisibleColumns from './utils/getVisibleColumns';
import { requiredWhen, requiredWhenNot } from '../utils/propTypes';
import getTableArgs from './utils/getTableArgs';
import TableControlBar from './TableControlBar';
import EmptyTableContent from './EmptyTable';
import TableFooter from './TableFooter';
import BulkActions from './BulkActions';
import DropdownFilters from './DropdownFilters';
import FilterStatus from './FilterStatus';
import RowStatus from './RowStatus';
import SelectionStatus from './selection/SelectionStatus';
import ControlledSelectionStatus from './selection/ControlledSelectionStatus';
import SmartStatus from './SmartStatus';
import TableFilters from './TableFilters';
import TableHeaderCell from './TableHeaderCell';
import TableCell from './TableCell';
import TableHeaderRow from './TableHeaderRow';
import TablePagination from './TablePagination';
import TablePaginationMinimal from './TablePaginationMinimal';
import DataTableContext from './DataTableContext';
import TableActions from './TableActions';
import ControlledSelect from './selection/ControlledSelect';
import ControlledSelectHeader from './selection/ControlledSelectHeader';
import DataTableLayout from './DataTableLayout';
import ExpandAll from './ExpandAll';
import ExpandRow from './ExpandRow';
import { useSelectionActions } from './hooks';
import selectionsReducer, { initialState as initialSelectionsState } from './selection/data/reducer';
function DataTable(_ref) {
  var columns = _ref.columns,
    data = _ref.data,
    defaultColumnValues = _ref.defaultColumnValues,
    additionalColumns = _ref.additionalColumns,
    isSelectable = _ref.isSelectable,
    isPaginated = _ref.isPaginated,
    manualPagination = _ref.manualPagination,
    pageCount = _ref.pageCount,
    itemCount = _ref.itemCount,
    isFilterable = _ref.isFilterable,
    manualFilters = _ref.manualFilters,
    fetchData = _ref.fetchData,
    initialState = _ref.initialState,
    isSortable = _ref.isSortable,
    manualSortBy = _ref.manualSortBy,
    isExpandable = _ref.isExpandable,
    renderRowSubComponent = _ref.renderRowSubComponent,
    bulkActions = _ref.bulkActions,
    tableActions = _ref.tableActions,
    numBreakoutFilters = _ref.numBreakoutFilters,
    initialTableOptions = _ref.initialTableOptions,
    EmptyTableComponent = _ref.EmptyTableComponent,
    manualSelectColumn = _ref.manualSelectColumn,
    showFiltersInSidebar = _ref.showFiltersInSidebar,
    dataViewToggleOptions = _ref.dataViewToggleOptions,
    disableElevation = _ref.disableElevation,
    isLoading = _ref.isLoading,
    children = _ref.children,
    onSelectedRowsChanged = _ref.onSelectedRowsChanged,
    maxSelectedRows = _ref.maxSelectedRows,
    onMaxSelectedRows = _ref.onMaxSelectedRows,
    props = _objectWithoutProperties(_ref, _excluded);
  var defaultColumn = useMemo(function () {
    return defaultColumnValues;
  }, [defaultColumnValues]);
  var tableOptions = useMemo(function () {
    var updatedTableOptions = _objectSpread({
      stateReducer: function stateReducer(newState, action, previousState) {
        switch (action.type) {
          // Note: we override the `toggleAllRowsSelected` action
          // from react-table because it only clears the selections on the
          // currently visible page; it does not clear the `selectedRowIds`
          // as we would expect for selections on different pages. Instead, we
          // force `selectedRowIds` to be cleared when `toggleAllRowsSelected(false)`
          // is called.
          case 'toggleAllRowsSelected':
            {
              if (action.value) {
                return newState;
              }
              return _objectSpread(_objectSpread({}, newState), {}, {
                selectedRowIds: {}
              });
            }
          /*  Note: We override the `toggleRowSelected` action from react-table
              because we need to preserve the order of the selected rows.
              While `selectedRowIds` is an object that contains the selected rows as key-value pairs,
              it does not maintain the order of selection. Therefore, we have added the `selectedRowsOrdered` property
              to keep track of the order in which the rows were selected.
          */
          case 'toggleRowSelected':
            {
              var rowIndex = parseInt(action.id, 10);
              var _previousState$select = previousState.selectedRowsOrdered,
                selectedRowsOrdered = _previousState$select === void 0 ? [] : _previousState$select;
              var newSelectedRowsOrdered;
              if (action.value) {
                newSelectedRowsOrdered = [].concat(_toConsumableArray(selectedRowsOrdered), [rowIndex]);
              } else {
                newSelectedRowsOrdered = selectedRowsOrdered.filter(function (item) {
                  return item !== rowIndex;
                });
              }
              return _objectSpread(_objectSpread({}, newState), {}, {
                selectedRowsOrdered: newSelectedRowsOrdered
              });
            }
          default:
            return newState;
        }
      }
    }, initialTableOptions);
    return _objectSpread({
      columns: columns,
      data: data,
      defaultColumn: defaultColumn,
      manualFilters: manualFilters,
      manualPagination: manualPagination,
      manualSortBy: manualSortBy,
      initialState: initialState
    }, updatedTableOptions);
  }, [initialTableOptions, columns, data, defaultColumn, manualFilters, manualPagination, manualSortBy, initialState]);
  var _useReducer = useReducer(selectionsReducer, initialSelectionsState),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    selections = _useReducer2[0],
    selectionsDispatch = _useReducer2[1];
  if (isPaginated && manualPagination) {
    // pageCount is required when pagination is manual, if it's not there passing -1 as per react-table docs
    tableOptions.pageCount = pageCount || -1;
  }

  // NB: Table args *must* be in a particular order
  var tableArgs = getTableArgs({
    tableOptions: tableOptions,
    isFilterable: isFilterable,
    isSelectable: isSelectable,
    isPaginated: isPaginated,
    isSortable: isSortable,
    isExpandable: isExpandable
  });
  // adds selection column and action columns as necessary
  tableArgs.push(function (hooks) {
    hooks.visibleColumns.push(function (visibleColumns) {
      return getVisibleColumns(isSelectable, visibleColumns, additionalColumns, manualSelectColumn);
    });
  });

  // Pass any controlled selections from context to the appropriate ``useTable`` arguments to maintain
  // correct selection states on rows, both from a data perspective and in the UI.
  var selectionProps = {};
  var selectedRows = selections.selectedRows;
  if (selectedRows.length > 0) {
    var selectedRowsById = {};
    selectedRows.forEach(function (row) {
      selectedRowsById[row.id] = true;
    });
    tableArgs.push(function (hooks) {
      hooks.useControlledState.push(function (state) {
        return _objectSpread(_objectSpread({}, state), {}, {
          selectedRowIds: selectedRowsById
        });
      });
    });
    selectionProps.selectedFlatRows = selectedRows;
  }
  var controlledTableSelections = [selections, selectionsDispatch];

  // Use the state and functions returned from useTable to build your UI
  var instance = useTable.apply(void 0, _toConsumableArray(tableArgs));
  var _instance$state = instance.state,
    tableStatePageSize = _instance$state.pageSize,
    tableStatePageIndex = _instance$state.pageIndex,
    tableStateSortBy = _instance$state.sortBy,
    tableStateFilters = _instance$state.filters,
    tableStateSelectedRowIds = _instance$state.selectedRowIds;
  useEffect(function () {
    if (fetchData) {
      fetchData({
        pageSize: tableStatePageSize,
        pageIndex: tableStatePageIndex,
        sortBy: tableStateSortBy,
        filters: tableStateFilters
      });
    }
  }, [fetchData, tableStatePageSize, tableStatePageIndex, tableStateSortBy, tableStateFilters]);
  useMountedLayoutEffect(function () {
    if (onSelectedRowsChanged) {
      onSelectedRowsChanged(tableStateSelectedRowIds);
    }
  }, [tableStateSelectedRowIds, onSelectedRowsChanged]);
  var selectionActions = useSelectionActions(instance, controlledTableSelections);
  var enhancedInstance = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, instance), {}, {
    manualFilters: manualFilters,
    itemCount: itemCount,
    numBreakoutFilters: numBreakoutFilters,
    bulkActions: bulkActions,
    tableActions: tableActions,
    controlledTableSelections: controlledTableSelections,
    showFiltersInSidebar: showFiltersInSidebar,
    dataViewToggleOptions: dataViewToggleOptions,
    renderRowSubComponent: renderRowSubComponent,
    disableElevation: disableElevation,
    isLoading: isLoading,
    isSelectable: isSelectable,
    isPaginated: isPaginated,
    manualSelectColumn: manualSelectColumn,
    maxSelectedRows: maxSelectedRows,
    onMaxSelectedRows: onMaxSelectedRows
  }, selectionProps), selectionActions), props);
  return /*#__PURE__*/React.createElement(DataTableContext.Provider, {
    value: enhancedInstance
  }, /*#__PURE__*/React.createElement(DataTableLayout, null, /*#__PURE__*/React.createElement("div", {
    className: classNames('pgn__data-table-wrapper', {
      'hide-shadow': !!disableElevation
    })
  }, children || /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TableControlBar, null), /*#__PURE__*/React.createElement(Table, null), /*#__PURE__*/React.createElement(EmptyTableComponent, {
    content: "No results found"
  }), /*#__PURE__*/React.createElement(TableFooter, null)))));
}
DataTable.defaultProps = {
  additionalColumns: [],
  defaultColumnValues: {},
  isFilterable: false,
  isPaginated: false,
  isSelectable: false,
  isSortable: false,
  manualFilters: false,
  manualPagination: false,
  manualSortBy: false,
  fetchData: null,
  initialState: {},
  initialTableOptions: {},
  EmptyTableComponent: EmptyTableContent,
  children: null,
  bulkActions: [],
  tableActions: [],
  numBreakoutFilters: 1,
  manualSelectColumn: undefined,
  SelectionStatusComponent: SelectionStatus,
  FilterStatusComponent: FilterStatus,
  RowStatusComponent: RowStatus,
  showFiltersInSidebar: false,
  dataViewToggleOptions: {
    isDataViewToggleEnabled: false,
    onDataViewToggle: function onDataViewToggle() {},
    defaultActiveStateValue: 'card',
    togglePlacement: 'left'
  },
  disableElevation: false,
  renderRowSubComponent: undefined,
  isExpandable: false,
  isLoading: false,
  onSelectedRowsChanged: undefined,
  maxSelectedRows: undefined,
  onMaxSelectedRows: undefined
};
DataTable.propTypes = {
  /** Definition of table columns */
  columns: PropTypes.arrayOf(PropTypes.shape({
    /** User visible column name */
    Header: PropTypes.oneOfType([PropTypes.elementType, PropTypes.node]).isRequired,
    /** String used to access the correct cell data for this column */
    accessor: requiredWhenNot(PropTypes.string, 'Cell'),
    /** Specifies a function that receives `row` as argument and returns cell content */
    Cell: PropTypes.oneOfType([PropTypes.elementType, PropTypes.node]),
    /** Specifies filter component */
    Filter: PropTypes.elementType,
    /** Specifies filter type */
    filter: PropTypes.string,
    /** Specifies filter choices */
    filterChoices: PropTypes.arrayOf(PropTypes.shape({
      name: PropTypes.string,
      number: PropTypes.number,
      value: PropTypes.string
    }))
  })).isRequired,
  /** Data to be displayed in the table */
  data: PropTypes.arrayOf(PropTypes.shape({})).isRequired,
  /** table rows can be selected */
  isSelectable: PropTypes.bool,
  /** Alternate column for selecting rows. See react table useSort docs for more information */
  manualSelectColumn: PropTypes.shape({
    id: PropTypes.string.isRequired,
    Header: PropTypes.oneOfType([PropTypes.elementType, PropTypes.node]).isRequired,
    Cell: PropTypes.oneOfType([PropTypes.elementType, PropTypes.node]),
    disableSortBy: PropTypes.bool.isRequired
  }),
  /** Table columns can be sorted */
  isSortable: PropTypes.bool,
  /** Indicates that sorting will be done via backend API. A fetchData function must be provided */
  manualSortBy: PropTypes.bool,
  /** Paginate the table */
  isPaginated: PropTypes.bool,
  /** Indicates that pagination will be done manually. A fetchData function must be provided */
  manualPagination: PropTypes.bool,
  // eslint-disable-next-line react/require-default-props
  pageCount: requiredWhen(PropTypes.number, 'manualPagination'),
  /** Table rows can be filtered, using a default filter in the default column values, or in the column definition */
  isFilterable: PropTypes.bool,
  /** Indicates that filtering will be done via a backend API. A fetchData function must be provided */
  manualFilters: PropTypes.bool,
  /** defaults that will be set on each column. Will be overridden by individual column values */
  defaultColumnValues: PropTypes.shape({
    /** A default filter component for the column */
    Filter: PropTypes.elementType
  }),
  /** Actions or other additional non-data columns can be added here  */
  additionalColumns: PropTypes.arrayOf(PropTypes.shape({
    /** id must be unique from other columns ids */
    id: PropTypes.string.isRequired,
    /** column header that will be displayed to the user */
    Header: PropTypes.oneOfType([PropTypes.elementType, PropTypes.node]),
    /** Component that renders in the added column. It will receive the row as a prop */
    Cell: PropTypes.oneOfType([PropTypes.elementType, PropTypes.node])
  })),
  /** Function that will fetch table data. Called when page size, page index or filters change.
    * Meant to be used with manual filters and pagination */
  fetchData: PropTypes.func,
  /** Initial state passed to react-table's documentation https://github.com/TanStack/table/blob/v7/docs/src/pages/docs/api/useTable.md */
  initialState: PropTypes.shape({
    pageSize: requiredWhen(PropTypes.number, 'isPaginated'),
    pageIndex: requiredWhen(PropTypes.number, 'isPaginated'),
    filters: requiredWhen(PropTypes.arrayOf(PropTypes.shape()), 'manualFilters'),
    sortBy: requiredWhen(PropTypes.arrayOf(PropTypes.shape()), 'manualSortBy'),
    selectedRowIds: PropTypes.shape(),
    selectedRowsOrdered: PropTypes.arrayOf(PropTypes.number)
  }),
  /** Table options passed to react-table's useTable hook. Will override some options passed in to DataTable, such
     as: data, columns, defaultColumn, manualFilters, manualPagination, manualSortBy, and initialState */
  initialTableOptions: PropTypes.shape({}),
  /** Actions to be performed on the table. Called with the table instance. Not displayed if rows are selected. */
  itemCount: PropTypes.number.isRequired,
  /** Actions to be performed on selected rows of the table. Called with the selected rows.
   *  Only displayed if rows are selected. */
  bulkActions: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.shape({
    /** Bulk action button text */
    buttonText: PropTypes.string.isRequired,
    /** handleClick will be passed the selected rows */
    handleClick: PropTypes.func.isRequired,
    /** classnames for button class */
    className: PropTypes.string,
    /** optional button variant; only relevant for the first two buttons */
    variant: PropTypes.string,
    /** disables button */
    disabled: PropTypes.bool
  }), /** function passed selected items, should return action object */
  PropTypes.func, /** A custom component representing an action */
  PropTypes.element])), /** Function for rendering custom components */
  PropTypes.func, /** A custom component representing an action */
  PropTypes.element]),
  /** Function for rendering custom components, called with the table instance */
  tableActions: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.shape({
    /** Bulk action button text */
    buttonText: PropTypes.string.isRequired,
    /** handleClick will be passed the selected rows */
    handleClick: PropTypes.func.isRequired,
    /** classnames for button class */
    className: PropTypes.string,
    /** optional button variant; only relevant for the first two buttons */
    variant: PropTypes.string,
    /** disables button */
    disabled: PropTypes.bool
  }), /** function passed table instance, should return action object */
  PropTypes.func, /** A custom component representing an action */
  PropTypes.element])), /** Function for rendering custom components */
  PropTypes.func, /** A custom component representing an action */
  PropTypes.element]),
  /** Number between one and four filters that can be shown on the top row. */
  numBreakoutFilters: PropTypes.oneOf([1, 2, 3, 4]),
  /** Component to be displayed when the table is empty */
  EmptyTableComponent: PropTypes.elementType,
  /** Component to be displayed for row status, ie, 10 of 20 rows. Displayed by default in the TableControlBar */
  RowStatusComponent: PropTypes.elementType,
  /** Component to be displayed for selection status. Displayed when there are selected rows and no active filters */
  SelectionStatusComponent: PropTypes.elementType,
  /** Component to be displayed for filter status. Displayed when there are active filters. */
  FilterStatusComponent: PropTypes.elementType,
  /** If children are not provided a table with control bar and footer will be rendered */
  children: PropTypes.node,
  /** If true filters will be shown on sidebar instead */
  showFiltersInSidebar: PropTypes.bool,
  /** options for data view toggle */
  dataViewToggleOptions: PropTypes.shape({
    /** Whether to show a toggle button group which allows view switching between card and table views */
    isDataViewToggleEnabled: PropTypes.bool,
    /** Callback invoked when the toggle buttons are clicked, with value of selected button passed in */
    onDataViewToggle: PropTypes.func,
    /** default value for toggle active state */
    defaultActiveStateValue: PropTypes.string,
    /** placement of toggle 'bottom' will push it to the bottom row in
     * actions section. Only 'left' and 'bottom' are supported */
    togglePlacement: PropTypes.string
  }),
  /** Remove the default box shadow on the component */
  disableElevation: PropTypes.bool,
  /** A function that will render contents of expanded row, accepts `row` as a prop. */
  renderRowSubComponent: PropTypes.func,
  /** Indicates whether table supports expandable rows. */
  isExpandable: PropTypes.bool,
  /** Indicates whether the table should show loading states. */
  isLoading: PropTypes.bool,
  /** Callback function called when row selections change. */
  onSelectedRowsChanged: PropTypes.func,
  /** Indicates the max of rows selectable in the table. Requires isSelectable prop */
  maxSelectedRows: PropTypes.number,
  /** Callback after selected max rows. Requires isSelectable and maxSelectedRows props */
  onMaxSelectedRows: PropTypes.func
};
DataTable.BulkActions = BulkActions;
DataTable.EmptyTable = EmptyTableContent;
DataTable.DropdownFilters = DropdownFilters;
DataTable.FilterStatus = FilterStatus;
DataTable.RowStatus = RowStatus;
DataTable.SelectionStatus = SelectionStatus;
DataTable.SmartStatus = SmartStatus;
DataTable.Table = Table;
DataTable.TableCell = TableCell;
DataTable.TableControlBar = TableControlBar;
DataTable.TableFilters = TableFilters;
DataTable.TableFooter = TableFooter;
DataTable.TableHeaderCell = TableHeaderCell;
DataTable.TableHeaderRow = TableHeaderRow;
DataTable.TablePagination = TablePagination;
DataTable.TablePaginationMinimal = TablePaginationMinimal;
DataTable.TableActions = TableActions;
DataTable.ControlledSelectionStatus = ControlledSelectionStatus;
DataTable.ControlledSelect = ControlledSelect;
DataTable.ControlledSelectHeader = ControlledSelectHeader;
DataTable.ExpandAll = ExpandAll;
DataTable.ExpandRow = ExpandRow;
export default DataTable;
//# sourceMappingURL=index.js.map